/*********************************************************************************/
/***                      Лабораторна робота №4                                ***/
/***                   Багатоінтервальна інтерполяція                          ***/
/***                          Варіант №11                                      ***/
/*** На початку програми, використовуючи y=f(x), побудувати таблицю її значень ***/
/*** в (n+1)-й точцi xi=a+iH, H=(b-a)/n, i=0,1,…,n. В усiх варiантах, якщо не  ***/
/*** вказано iншого, взяти n=5. Якщо поліном будується у канонічному вигляді   ***/
/*** надрукувати його коефіцієнти. У програмі побудуйте таблицю значень: x;    ***/
/*** точне f(x), наближене (x), абсолютну похибку f(x)-(x), відносну похибку ***/
/*** (f(x)-(x))100/ f(x) з кроком h=(b-a)/(4n) для відрізку [a-H, b+H]. У     ***/
/*** будь-якому вариантi необхiдно надрукувати на одному полi в загальному     ***/
/*** масштабi графiки функцiй  f(x) та (x) на тому ж відрізку.                ***/
/*** У випадку багатоiнтервальної інтерполяції (x) являє собою набір поліномів***/
/*** невеликого степеня, коефіцієнти яких зберігаються в прямокутному масиві.  ***/
/*** Визначити аналітично, програмно полiном-похiдну та побудувати на одному   ***/
/*** полі графіки цих функцій з кроком h на відрізку [a-H, b+H].               ***/
/***															  f(x)=x^2 + sin(x), x e [-1;3]              ***/
/***                                Роботу виконав: Костриця Сергій ТР-71      ***/
/*********************************************************************************/
#define N 6
#include <iostream>
#include <fstream>
#include <iomanip>
#include <conio.h>
#include <cmath>
using namespace std;

int main()
{
	int a = -1;
	int b = 3;
	const int K = 4 * N;
	double h = (b - a) / (double)N;
	double X[N + 1];
	double Y[N + 1];
	double A[N][2];
	int k = 0;
	ofstream out("D:\GNUP.txt");
	double x = -1;
	double H = (b - a) / (double)5000;
	for (int i = 0; i < 5000; i++) {
		x = a + (i * H);
		out << x << ' ' << x * x + sin(x * 3.14) << endl;
	}

	for (int i = 0; i < N + 1; i++)
	{
		X[i] = a + (i * h);
		Y[i] = X[i] * X[i] + sin(X[i] * 3.14);
	}
	out.close();
	double XR[(N - 1)*K + N];
	double YR[(N - 1)*K + N];

	for (int i = 0; i < ((N - 1)*K + N); i++)
	{
		XR[i] = a + (i*h) / (K + 1);
	}

	for (k = 0; k < (N - 1); k++)
	{
		if ((X[k] >= X[k]) && (X[k] < X[k + 1]))
		{
			A[k][1] = (Y[k + 1] - Y[k]) / (X[k + 1] - X[k]);
			A[k][0] = Y[k] - X[k] * A[k][1];
		}
		if (X[k] < X[0])
		{
			A[k][1] = (Y[1] - Y[0]) / (X[1] - X[0]);
			A[k][0] = Y[0] - X[0] * A[k][1];
		}
		if (X[k] > X[N - 1])
		{
			A[k][1] = (Y[N - 1] - Y[N - 2]) / (X[N - 1] - X[N - 2]);
			A[k][0] = Y[N - 2] - X[N - 2] * A[k][1];
		}
		for (int i = k * (K + 1); i < ((N - 1)*K + N); i++)
		{
			YR[i] = A[k][0] + A[k][1] * XR[i];
		}
	}

	cout << "  X        |    ft(x)   |    f(x)    |ft(x) - f(x)|(ft(x)-f(x))*100/ft(x) " << endl;
	for (int i = 0; i < 73; i++)
	{
		cout << '-';
	}
	cout << endl;
	for (int i = 0; i < (N - 1)*K + N; i+=4)
	{
		
		cout << setw(10) <<setprecision(5)<< XR[i] << " | " << setprecision(5) <<setw(10) << XR[i] * XR[i] + sin(XR[i] * 3.14) << " | "
			<< setw(10) << YR[i] << " | " << setw(10) << fabs(XR[i] * XR[i] + sin(XR[i] * 3.14) - YR[i])
			<< " | " << setw(10) << fabs(XR[i] * XR[i] + sin(XR[i] * 3.14) - YR[i]) / (XR[i] * XR[i] + sin(XR[i] * 3.14)) * 100.0;
		out << setw(10) << XR[i] << " | " << setw(10) << XR[i] * XR[i] + sin(XR[i] * 3.14) << " | "
			<< setw(10) << YR[i] << " | " << setw(10) << fabs(XR[i] * XR[i] + sin(XR[i] * 3.14) - YR[i])
			<< " | " << fabs(XR[i] * XR[i] + sin(XR[i] * 3.14) - YR[i]) / (XR[i] * XR[i] + sin(XR[i] * 3.14)) * 100.0;
		if (fabs(XR[i] * XR[i] + sin(XR[i] * 3.14) - YR[i]) < 1e-6)
		{
			cout << '*';
			out << '*';
		}
		cout << endl;
	out << endl;
	}
	out.open("D:\GNUPIK.txt");
	for (int i = 0; i < (N - 1)*K + N; i++)
	{
		out << XR[i] << ' ' << YR[i] << endl;
	}

	system("pause");
	return 0;
}