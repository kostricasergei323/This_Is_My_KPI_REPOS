/**********************************************************************************************************/
/*** 									  Лабороторна робота №3 										***/
/*** 										   Варiант №5		 										***/
/*** 											З курсу		 											***/
/*** 										Чисельнi методи 											***/
/*** 								ІТЕРАЦІЙНІ МЕТОДИ РОЗВ'ЯЗУВАННЯ СИСТЕМ								***/
/***									ЛІНІЙНИХ АЛГЕБРАЇЧНИХ РІВНЯНЬ									***/
/*** 											Завдання: 												***/
/***	Скласти програму для розв'язування системи iтерацiйним методом послiдовних наближень.			***/
/***	Передбачити максимально допустиму кількість iтерацiй 40. На кожнiй iтерацiї надрукувати її		***/
/***	номер i вектор невiдомих. Надрукувати початкову та перетворену системи. У програмi передбачити	***/
/***	побудову графiка залежностi величини || x(n)- x*||  від n  для  n=1, 2,...,k при  e =10-6.		***/
/***																Виконав:	Журавльов Роман ТР-71	***/
/**********************************************************************************************************/

#include <iostream>
#include <iomanip>
#include <conio.h>
#include <math.h>

using namespace std;

float a[3][3];
float b[3];
float x[3];
int n = 3;
float eps = 0.0001;


void init();				// Инициализация начальной матрицы
void print();				// Вывод матрицы
void gradApprox();			// Решение слау методом простых итераций
void miss();				// Погрешность


int main()
{
  system("chcp 1251 & cls");
  // Инициализация матрицы
  init();
  // Вывод условия
  print();
  // Решение слау
  gradApprox();
  // Вывод погрешности
  miss();
  getchar();
}


// Инициализация матрицы
void init() {
  a[0][0] = 2;	a[0][1] = 2;	a[0][2] = 10; 		b[0] = 14;
  a[1][0] = 10;   a[1][1] = 1;   a[1][2] = 1;		b[1] = 12;
  a[2][0] = 2;	a[2][1] = 10;	a[2][2] = 1;		b[2] = 13;
}

//void init() {
//	a[0][0] = -2.8;	a[0][1] = 1;	a[0][2] = 4; 		b[0] = 60;
//	a[1][0] = 10;   a[1][1] = -1;   a[1][2] = 8;		b[1] = 10;
//	a[2][0] = -1;	a[2][1] = 2;	a[2][2] = -0.6;		b[2] = 20;
//}


// Вывод матрицы
void print() {
  cout << "\n";
  for (int i = 0; i < n; i++)
  {
    for (int j = 0; j < n; j++)
    {
      cout << fixed << setprecision(1) << setw(5) << a[i][j] << "  ";
    }
    cout << "=  " << b[i] << "\n";
  }
  cout << "\n";
}

// Метод Зейделя
void gradApprox()
{
  float xk[3];
  float sum;
  float acc;
  int k = 0;
  // Перестановка рядкiв матрицi щоб елементи головноi дiагоналi були бiльше суми модулiв iнших елементiв рядка
  for (int j = 0; j < n; j++) {
    for (int i = 0; i < n; i++) {
      // Пошук суми елементiв рядка
      sum = 0;
      for (int k = 0; k < n; k++) {
        sum += fabs(a[i][k]);
      }
      sum -= fabs(a[i][j]);
      // Перестановка рядкiв
      if (a[i][j] > sum)
      {
        for (int l = 0; l < n; l++) {
          swap(a[j][l], a[i][l]);
        }
        swap(b[j], b[i]);
      }
    }
  }
  // Перетворення матрицi до вигляду x = ax + b
  for (int i = 0; i < n; i++) {
    b[i] /= a[i][i];
    for (int j = 0; j < n; j++) {
      if (j != i) {
        a[i][j] /= -a[i][i];
      }
    }
    a[i][i] = 0;
  }
  print();
  // Перевiра на схiднiсть
  for (int i = 0; i < n; i++) {
    sum = 0;
    for (int j = 0; j < n; j++) {
      sum += fabs(a[i][j]);
    }
    if (sum >= 1) {
      cout << "\n Помилка! Матриця не сходиться!\n";
      return;
    }
  }
  // Обчислення матрицi
  cout << "   i         x1         x2         x3         eps\n";
  for (int i = 0; i < n; i++) {
    x[i] = b[i];
  }
  for (int k = 0; k < 40; k++) {
    // Обчислення x(k + 1)
    for (int i = 0; i < n; i++) {
      xk[i] = 0;
      for (int j = 0; j < n; j++) {
        xk[i] += a[i][j] * x[j];
      }
      xk[i] += b[i];
    }
    // Обчислення точностi
    acc = abs(xk[n - 1] - x[n - 1]);
    // Вивiд результатiв
    cout << endl << fixed << setprecision(5) << setw(4) << k + 1 << " ";
    cout << setw(11) << xk[0] << " " << setw(10) << xk[1] << " " << setw(10) << xk[2] << " " << setw(11) << acc;
    for (int i = 0; i < n; i++) {
      x[i] = xk[i];
    }
    if (eps > acc) {
      cout << "\n\nРозв'язок знайдено.\n";
      return;
    }
  }
  cout << "\nIтераційний процес не збігається.\n";
}

//  Вычисление погрешности
void miss()
{
  init();
  cout << "\n";
  for (int i = 0; i < n; i++)
  {
    cout << "x[" << i + 1 << "] = " << x[i] << endl;
  }
  cout << "\n";
  for (int i = 0; i < n; i++)
  {
    double s = 0;								// Сума ряда
    for (int j = 0; j < n; j++)
    {
      s += a[i][j] * x[j];
    }
    printf("a[%d] = %lf\n", i + 1, s - b[i]);	// Вывод каждой погрешности
  }
}